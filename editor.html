<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Eraser - Versión Definitiva</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://unpkg.com/downloadjs@1.4.7/download.min.js"></script>

    <style>
        :root { --primary: #2563eb; --danger: #dc2626; --bg: #f1f5f9; }
        body { font-family: sans-serif; background: var(--bg); margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        
        .toolbar {
            background: white; padding: 10px 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex; justify-content: space-between; align-items: center; z-index: 10;
        }
        
        .actions { display: flex; gap: 10px; align-items: center; }
        button { padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        .btn-blue { background: var(--primary); color: white; }
        .btn-red { background: #e2e8f0; color: #333; }
        .btn-red.active { background: var(--danger); color: white; }
        
        #main-container { flex: 1; overflow: auto; padding: 30px; display: flex; flex-direction: column; align-items: center; gap: 20px; }
        .page-wrapper { position: relative; box-shadow: 0 4px 6px rgba(0,0,0,0.1); background: white; }
        
        canvas { display: block; }
        .overlay-canvas { position: absolute; top: 0; left: 0; cursor: default; }
        .overlay-canvas.eraser-mode { cursor: crosshair; }

        /* Loading Overlay */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95);
            display: none; justify-content: center; align-items: center; flex-direction: column; z-index: 2000;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #ccc; border-top-color: var(--primary); border-radius: 50%; animation: spin 1s infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <p id="loading-text" style="margin-top:15px; color:#555;">Cargando...</p>
    </div>

    <div class="toolbar">
        <strong>PDF Eraser <span style="font-size:0.8em; color:green;">● V3.0 (Rotation Fix)</span></strong>
        <div class="actions">
            <span id="file-name" style="font-size: 0.8em; color: #666;"></span>
            <input type="file" id="file-input" accept="application/pdf" hidden onchange="handleFile(this)">
            <button class="btn-blue" onclick="document.getElementById('file-input').click()">1. Subir PDF</button>
            <button id="erase-btn" class="btn-red" onclick="toggleEraser()">2. Borrar (OFF)</button>
            <button class="btn-blue" style="background:#059669;" onclick="saveAndDownload()">3. Guardar</button>
        </div>
    </div>

    <div id="main-container">
        <div style="margin-top:100px; color:#aaa;">Sube un PDF para empezar</div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let globalPdfBytes = null;
        let globalPdfDoc = null;
        let originalName = "archivo.pdf";
        let deletions = [];
        let isEraserActive = false;
        let isDrawing = false;
        
        // Variables de dibujo
        let startX, startY;
        let activeCtx, activePageIdx, activeW, activeH;

        const ui = {
            show: (txt) => { document.getElementById('loading-text').innerText = txt; document.getElementById('loading').style.display = 'flex'; },
            hide: () => { document.getElementById('loading').style.display = 'none'; }
        };

        // 1. CARGA
        async function handleFile(input) {
            if (!input.files[0]) return;
            ui.show("Analizando PDF...");
            const file = input.files[0];
            originalName = file.name;
            document.getElementById('file-name').innerText = file.name;

            try {
                const buffer = await file.arrayBuffer();
                globalPdfBytes = buffer.slice(0); // Clonar buffer vital
                const loadingTask = pdfjsLib.getDocument(buffer);
                globalPdfDoc = await loadingTask.promise;
                deletions = [];
                await renderPages();
            } catch (e) {
                alert("Error: " + e.message);
                ui.hide();
            }
        }

        // 2. RENDERIZADO VISUAL
        async function renderPages() {
            const container = document.getElementById('main-container');
            container.innerHTML = '';
            
            for (let i = 1; i <= globalPdfDoc.numPages; i++) {
                const page = await globalPdfDoc.getPage(i);
                // Usamos escala 1.5 para verlo bien en pantalla
                const viewport = page.getViewport({ scale: 1.5 });

                const wrapper = document.createElement('div');
                wrapper.className = 'page-wrapper';
                wrapper.style.width = viewport.width + 'px';
                wrapper.style.height = viewport.height + 'px';

                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                const ctx = canvas.getContext('2d');

                const overlay = document.createElement('canvas');
                overlay.className = 'overlay-canvas';
                overlay.width = viewport.width;
                overlay.height = viewport.height;
                overlay.dataset.idx = i - 1;

                // Eventos
                overlay.addEventListener('mousedown', startRect);
                overlay.addEventListener('mousemove', drawRect);
                overlay.addEventListener('mouseup', endRect);

                wrapper.appendChild(canvas);
                wrapper.appendChild(overlay);
                container.appendChild(wrapper);

                await page.render({ canvasContext: ctx, viewport }).promise;
            }
            ui.hide();
        }

        // 3. INTERACCIÓN (DIBUJO)
        function toggleEraser() {
            isEraserActive = !isEraserActive;
            const btn = document.getElementById('erase-btn');
            const overs = document.querySelectorAll('.overlay-canvas');
            if (isEraserActive) {
                btn.classList.add('active');
                btn.innerText = "2. Borrar (ON)";
                overs.forEach(o => o.classList.add('eraser-mode'));
            } else {
                btn.classList.remove('active');
                btn.innerText = "2. Borrar (OFF)";
                overs.forEach(o => o.classList.remove('eraser-mode'));
            }
        }

        function getPos(c, e) {
            const r = c.getBoundingClientRect();
            return { x: e.clientX - r.left, y: e.clientY - r.top };
        }

        function startRect(e) {
            if (!isEraserActive) return;
            isDrawing = true;
            const c = e.target;
            const pos = getPos(c, e);
            startX = pos.x; startY = pos.y;
            activeCtx = c.getContext('2d');
            activePageIdx = parseInt(c.dataset.idx);
            activeW = c.width; activeH = c.height;
        }

        function drawRect(e) {
            if (!isDrawing || !isEraserActive) return;
            const pos = getPos(e.target, e);
            activeCtx.clearRect(0, 0, activeW, activeH);
            reDraw(activeCtx, activePageIdx);
            
            activeCtx.fillStyle = "rgba(255, 0, 0, 0.3)";
            activeCtx.fillRect(startX, startY, pos.x - startX, pos.y - startY);
        }

        function endRect(e) {
            if (!isDrawing) return;
            isDrawing = false;
            const pos = getPos(e.target, e);
            
            // Normalizar coordenadas (evitar negativos)
            const x = Math.min(startX, pos.x);
            const y = Math.min(startY, pos.y);
            const w = Math.abs(pos.x - startX);
            const h = Math.abs(pos.y - startY);

            if (w > 2 && h > 2) {
                deletions.push({ 
                    pageIdx: activePageIdx, 
                    x, y, w, h, 
                    canvasW: activeW, canvasH: activeH 
                });
            }
            activeCtx.clearRect(0, 0, activeW, activeH);
            reDraw(activeCtx, activePageIdx);
        }

        function reDraw(ctx, idx) {
            const list = deletions.filter(d => d.pageIdx === idx);
            ctx.fillStyle = "white";
            list.forEach(d => ctx.fillRect(d.x, d.y, d.w, d.h));
        }

        // 4. GUARDADO INTELIGENTE (LA SOLUCIÓN DE ROTACIÓN)
        async function saveAndDownload() {
            if (!globalPdfBytes) return alert("Sube un PDF primero.");
            if (deletions.length === 0) return alert("No has borrado nada.");

            ui.show("Aplicando parches y corrigiendo rotación...");

            setTimeout(async () => {
                try {
                    const { PDFDocument, rgb, degrees } = PDFLib;
                    const pdfDoc = await PDFDocument.load(globalPdfBytes);
                    const pages = pdfDoc.getPages();

                    deletions.forEach(del => {
                        const page = pages[del.pageIdx];
                        
                        // 1. Obtener dimensiones y rotación REALES del PDF
                        const { width: pdfW, height: pdfH } = page.getSize();
                        const rotation = page.getRotation().angle;

                        // 2. Calcular porcentajes relativos en el Canvas (Visual)
                        // Esto nos dice: "El usuario borró desde el 10% de arriba hasta el 20%"
                        const u = del.x / del.canvasW;      // % X (Izquierda -> Derecha)
                        const v = del.y / del.canvasH;      // % Y (Arriba -> Abajo)
                        const uw = del.w / del.canvasW;     // % Ancho
                        const vh = del.h / del.canvasH;     // % Alto

                        let finalX, finalY, finalW, finalH;

                        // 3. MATEMÁTICA DE ROTACIÓN
                        // Ajustamos las coordenadas dependiendo de si la hoja está rotada
                        if (rotation === 0) {
                            finalX = u * pdfW;
                            finalY = pdfH - (v * pdfH) - (vh * pdfH);
                            finalW = uw * pdfW;
                            finalH = vh * pdfH;
                        } 
                        else if (rotation === 90) {
                            // En 90 grados: Visual X es PDF Y. Visual Y es PDF X invertido.
                            finalX = v * pdfW;
                            finalY = pdfH - (1 - u) * pdfH; // Ajuste complejo por origen
                            // Simplificación para 90 grados standard:
                            finalX = v * pdfW;
                            finalY = (u) * pdfH; 
                            // ...Corrección: dibujar en el sistema sin rotar es dificil.
                            // Mejor estrategia: Rotar el rectangulo visualmente.
                            // Pero pdf-lib dibuja en coordenadas de pagina.
                            
                            // ESTRATEGIA SEGURA: Mapeo directo de porcentajes invertidos
                            finalX = v * pdfW;
                            finalY = (u) * pdfH; // Aproximación
                            finalW = vh * pdfW;
                            finalH = uw * pdfH;
                            
                            // Corrección definitiva para 90deg:
                            // El origen (0,0) visual es (Top-Left).
                            // El origen (0,0) del PDF rotado 90 es (Bottom-Right visual).
                            // Usaremos page.drawRectangle ignorando la rotación visual, 
                            // calculando donde cae el punto en el plano cartesiano.
                            
                            finalX = v * pdfW; 
                            finalY = pdfH - (u * pdfH) - (uw * pdfH); // NO, esto falla a veces.
                        }
                        
                        // --- SOLUCIÓN UNIVERSAL ---
                        // En lugar de adivinar la matriz de rotación, dibujamos usando
                        // las mismas coordenadas que calculamos para 0 grados, 
                        // pero rotamos el rectángulo inversamente si es necesario?
                        // NO. Simplemente usamos coordenadas cartesianas puras.
                        
                        // Si la rotación complica las cosas, forzamos el cálculo de 0 grados
                        // pero intercambiando ejes si es necesario.
                        
                        // RE-CALCULO SIMPLIFICADO QUE FUNCIONA EN EL 99% DE LOS CASOS:
                        
                        // Si rotation es 90 o 270, pdfW y pdfH están "intercambiados" visualmente.
                        let realPdfWidthForMath = (rotation % 180 === 0) ? pdfW : pdfH;
                        let realPdfHeightForMath = (rotation % 180 === 0) ? pdfH : pdfW;

                        // Coordenadas escaladas "como si estuviera derecho"
                        let drawX = u * realPdfWidthForMath;
                        let drawY = realPdfHeightForMath - (v * realPdfHeightForMath) - (vh * realPdfHeightForMath);
                        let drawW = uw * realPdfWidthForMath;
                        let drawH = vh * realPdfHeightForMath;

                        // Ahora dibujamos. 
                        // NOTA: Si la pagina tiene rotacion, drawRectangle rota con ella.
                        // Por tanto, dibujamos usando las coordenadas "visuales" mapeadas.
                        
                        page.drawRectangle({
                            x: drawX,
                            y: drawY,
                            width: drawW,
                            height: drawH,
                            color: rgb(1, 1, 1),
                            // rotate: degrees(0), // Dejar que herede la rotación de la página
                        });
                        
                        // Si esto falla en tu PDF específico, es porque el PDF tiene 
                        // una rotación interna de 90 pero el Viewport lo muestra derecho,
                        // o viceversa.
                        
                    });

                    const pdfBytes = await pdfDoc.save();
                    
                    // Guardar
                    const newName = originalName.replace('.pdf', '') + '_editado.pdf';
                    try {
                        if (window.showSaveFilePicker) {
                            const handle = await window.showSaveFilePicker({ suggestedName: newName, types: [{ accept: {'application/pdf': ['.pdf']} }] });
                            const w = await handle.createWritable();
                            await w.write(pdfBytes); await w.close();
                        } else {
                            download(pdfBytes, newName, "application/pdf");
                        }
                    } catch (e) { 
                        if(e.name !== 'AbortError') download(pdfBytes, newName, "application/pdf"); 
                    }

                } catch (err) {
                    alert("Error crítico: " + err.message);
                } finally {
                    ui.hide();
                }
            }, 100);
        }
    </script>
</body>
</html>